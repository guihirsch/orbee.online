#!/usr/bin/env python3
"""
HLS Degradation Analysis - An√°lise de Degrada√ß√£o da Mata Ciliar
Fun√ß√µes para an√°lise de degrada√ß√£o e gera√ß√£o de pontos cr√≠ticos
"""

import os
import json
import numpy as np
import geopandas as gpd
from shapely.geometry import Point
import rasterio
from pyproj import Transformer
import hashlib
from datetime import datetime

# Importar configura√ß√µes centralizadas
try:
    from .config_hls import get_config
except ImportError:
    from config_hls import get_config

# Carregar configura√ß√µes centralizadas
config = get_config()

# Configura√ß√µes globais (usando configura√ß√µes centralizadas)
NDVI_CRITICAL_THRESHOLD = config['ndvi']['critical_threshold']
NDVI_MODERATE_THRESHOLD = config['ndvi']['moderate_threshold']
MIN_DISTANCE_POINTS = config['points']['min_distance']
MAX_POINTS_PER_SEVERITY = config['points']['max_per_severity']
BUFFER_DISTANCE_RIVER = config['degradation']['buffer_distance_river']

def generate_unique_point_id(lat, lon, ndvi_value=None, timestamp=None):
    """
    Gera um ID √∫nico para cada ponto baseado APENAS nas coordenadas geogr√°ficas
    Isso permite referenciar o mesmo local em an√°lises futuras
    
    Args:
        lat: Latitude do ponto (WGS84)
        lon: Longitude do ponto (WGS84)
        ndvi_value: Valor NDVI (n√£o usado no ID, apenas para compatibilidade)
        timestamp: Timestamp (n√£o usado no ID, apenas para compatibilidade)
    
    Returns:
        str: ID √∫nico no formato 'hls_point_<hash>' baseado apenas nas coordenadas
    """
    # Criar string √∫nica baseada APENAS nas coordenadas
    # Usar precis√£o de 6 casas decimais para coordenadas (aproximadamente 0.1m de precis√£o)
    # Isso garante que o mesmo local geogr√°fico sempre tenha o mesmo ID
    unique_string = f"{lat:.6f}_{lon:.6f}"
    
    # Gerar hash SHA-256 e usar primeiros 12 caracteres
    hash_object = hashlib.sha256(unique_string.encode())
    hash_hex = hash_object.hexdigest()[:12]
    
    return f"hls_point_{hash_hex}"

def classify_vegetation_degradation(ndvi_value):
    """Classifica a cobertura/condi√ß√£o da vegeta√ß√£o baseada no NDVI"""
    
    if np.isnan(ndvi_value):
        return {
            'level': 'no_data',
            'color': '#808080',
            'label': 'Sem Dados',
            'severity': 'unknown'
        }
    elif ndvi_value < 0.0:
        return {
            'level': 'non_vegetated',
            'color': '#0066CC',
            'label': 'Sem vegeta√ß√£o (√°gua/nuvem/neve/rocha)',
            'severity': 'non_vegetated'
        }
    elif ndvi_value < 0.2:
        return {
            'level': 'very_sparse',
            'color': '#DC143C',
            'label': 'Vegeta√ß√£o muito rala / solo exposto',
            'severity': 'very_sparse'
        }
    elif ndvi_value < 0.5:
        return {
            'level': 'sparse',
            'color': '#FF8C00',
            'label': 'Vegeta√ß√£o esparsa / em regenera√ß√£o',
            'severity': 'sparse'
        }
    elif ndvi_value < 0.8:
        return {
            'level': 'dense',
            'color': '#228B22',
            'label': 'Vegeta√ß√£o densa e saud√°vel',
            'severity': 'dense'
        }
    else:
        return {
            'level': 'extremely_dense',
            'color': '#006400',
            'label': 'Cobertura extremamente densa (rara)',
            'severity': 'extremely_dense'
        }

def analyze_riparian_forest_degradation(ndvi_data, aoi_buffer_gdf):
    """Analisa degrada√ß√£o da mata ciliar dentro do buffer"""
    
    if not ndvi_data or 'ndvi' not in ndvi_data:
        print("‚ùå Dados NDVI n√£o dispon√≠veis para an√°lise")
        return None

    ndvi_array = ndvi_data['ndvi']
    print(f"üìä Analisando degrada√ß√£o da mata ciliar...")
    print(f"   üìê Dimens√µes NDVI: {ndvi_array.shape}")

    # Converter buffer para o CRS do NDVI
    buffer_crs = ndvi_array.rio.crs
    if buffer_crs is None:
        print("‚ùå NDVI array n√£o possui CRS definido! Tentando definir manualmente...")

        # Verificar se temos dados de origem com CRS
        if 'source_items' in ndvi_data and len(ndvi_data['source_items']) > 0:
            # Usar CRS do primeiro item processado
            first_item_data = ndvi_data['source_items'][0]
            if 'ndvi' in first_item_data and first_item_data['ndvi'].rio.crs is not None:
                buffer_crs = first_item_data['ndvi'].rio.crs
                ndvi_array = ndvi_array.rio.write_crs(buffer_crs, inplace=True)
                print(f"‚úÖ CRS herdado dos dados HLS originais: {buffer_crs}")
            else:
                # Fallback: usar UTM baseado na localiza√ß√£o do AOI
                centroid = aoi_buffer_gdf.geometry.centroid.iloc[0]
                utm_zone = int((centroid.x + 180) / 6) + 1
                # For√ßar hemisf√©rio sul para esta regi√£o espec√≠fica
                if centroid.y < 0:  # Hemisf√©rio sul
                    buffer_crs = f"EPSG:{32700 + utm_zone}"
                    print(f"‚úÖ CRS definido para hemisf√©rio sul: {buffer_crs}")
                else:  # Hemisf√©rio norte
                    buffer_crs = f"EPSG:{32600 + utm_zone}"
                    print(f"‚úÖ CRS definido para hemisf√©rio norte: {buffer_crs}")
                ndvi_array = ndvi_array.rio.write_crs(buffer_crs, inplace=True)
        else:
            # Inferir CRS baseado nos bounds do NDVI
            ndvi_bounds = ndvi_array.rio.bounds()
            ndvi_y_center = (ndvi_bounds[1] + ndvi_bounds[3]) / 2

            # Se Y √© negativo, estamos no hemisf√©rio sul
            if ndvi_y_center < 0:
                # Estimar zona UTM baseada no AOI
                centroid = aoi_buffer_gdf.geometry.centroid.iloc[0]
                utm_zone = int((centroid.x + 180) / 6) + 1
                buffer_crs = f"EPSG:{32700 + utm_zone}"  # Hemisf√©rio sul
                print(f"‚úÖ CRS inferido dos bounds NDVI (hemisf√©rio sul): {buffer_crs}")
            else:
                # Hemisf√©rio norte
                centroid = aoi_buffer_gdf.geometry.centroid.iloc[0]
                utm_zone = int((centroid.x + 180) / 6) + 1
                buffer_crs = f"EPSG:{32600 + utm_zone}"  # Hemisf√©rio norte
                print(f"‚úÖ CRS inferido dos bounds NDVI (hemisf√©rio norte): {buffer_crs}")

            ndvi_array = ndvi_array.rio.write_crs(buffer_crs, inplace=True)

    print(f"   üîÑ Reprojetando buffer de {aoi_buffer_gdf.crs} para {buffer_crs}...")
    buffer_reproj = aoi_buffer_gdf.to_crs(buffer_crs)

    # Verificar se a reproje√ß√£o est√° no hemisf√©rio correto
    reproj_bounds = buffer_reproj.total_bounds
    reproj_y_center = (reproj_bounds[1] + reproj_bounds[3]) / 2

    # Se esperamos hemisf√©rio sul mas temos coordenadas positivas, h√° problema
    crs_code = int(str(buffer_crs).split(':')[-1])
    is_south_utm = 32700 <= crs_code <= 32799
    if is_south_utm and reproj_y_center > 0:
        print(f"   ‚ö†Ô∏è Problema detectado: CRS Sul mas coordenadas Norte!")
        print(f"   üîß Corrigindo reproje√ß√£o...")

        # Corrigir coordenadas Y usando offset baseado nos dados NDVI
        ndvi_bounds = ndvi_array.rio.bounds()
        if ndvi_bounds[1] < 0:  # NDVI est√° no hemisf√©rio sul
            print(f"   üîß Aplicando corre√ß√£o de hemisf√©rio baseada nos dados NDVI...")

            # Calcular offset necess√°rio para colocar Y no hemisf√©rio correto
            y_offset = -10000000  # For√ßar hemisf√©rio sul

            # Fun√ß√£o para corrigir coordenadas
            def fix_coordinates(geom):
                def coord_transform(x, y, z=None):
                    return (x, y + y_offset, z) if z is not None else (x, y + y_offset)

                from shapely.ops import transform
                return transform(coord_transform, geom)

            # Aplicar corre√ß√£o
            corrected_geoms = buffer_reproj.geometry.apply(fix_coordinates)
            buffer_reproj = gpd.GeoDataFrame(geometry=corrected_geoms, crs=buffer_crs)
            print(f"   ‚úÖ Coordenadas corrigidas para hemisf√©rio sul")

    print(f"   üó∫Ô∏è CRS NDVI: {buffer_crs}")
    print(f"   üåä Buffer reprojetado para an√°lise")
    print(f"   üìç Buffer original bounds: {aoi_buffer_gdf.total_bounds}")
    print(f"   üìç Buffer reprojetado bounds: {buffer_reproj.total_bounds}")

    # Criar m√°scara do buffer
    try:
        # Diagn√≥stico de bounds antes do clipping
        print(f"   üîç Diagn√≥stico de bounds:")
        ndvi_bounds = ndvi_array.rio.bounds()
        buffer_bounds = buffer_reproj.total_bounds
        print(f"      - NDVI bounds: {ndvi_bounds}")
        print(f"      - Buffer bounds: {buffer_bounds}")

        # Verificar se h√° intersec√ß√£o
        ndvi_minx, ndvi_miny, ndvi_maxx, ndvi_maxy = ndvi_bounds
        buf_minx, buf_miny, buf_maxx, buf_maxy = buffer_bounds

        intersects = not (buf_maxx < ndvi_minx or buf_minx > ndvi_maxx or
                         buf_maxy < ndvi_miny or buf_miny > ndvi_maxy)

        print(f"      - Intersec√ß√£o detectada: {intersects}")

        if not intersects:
            print("‚ùå Buffer n√£o intersecta com dados NDVI!")
            return None

        # Usar rioxarray para clip
        print(f"   ‚úÇÔ∏è Executando clipping...")
        ndvi_clipped = ndvi_array.rio.clip(buffer_reproj.geometry, buffer_reproj.crs)
        print(f"   ‚úÖ NDVI recortado para buffer da mata ciliar")
        print(f"   üìê Dimens√µes ap√≥s clipping: {ndvi_clipped.shape}")

        # Estat√≠sticas dentro do buffer
        valid_ndvi = ndvi_clipped.values[~np.isnan(ndvi_clipped.values)]

        print(f"   üìä Pixels ap√≥s clipping:")
        print(f"      - Total: {ndvi_clipped.size}")
        print(f"      - V√°lidos: {len(valid_ndvi)}")
        print(f"      - NaN: {ndvi_clipped.size - len(valid_ndvi)}")

        if len(valid_ndvi) == 0:
            print("‚ùå Nenhum pixel NDVI v√°lido dentro do buffer")
            return None

        # Calcular estat√≠sticas de degrada√ß√£o
        critical_pixels = np.sum(valid_ndvi < NDVI_CRITICAL_THRESHOLD)
        moderate_pixels = np.sum((valid_ndvi >= NDVI_CRITICAL_THRESHOLD) &
                                (valid_ndvi < NDVI_MODERATE_THRESHOLD))
        healthy_pixels = np.sum(valid_ndvi >= NDVI_MODERATE_THRESHOLD)
        total_valid_pixels = len(valid_ndvi)

        # Fra√ß√µes
        critical_fraction = critical_pixels / total_valid_pixels
        moderate_fraction = moderate_pixels / total_valid_pixels
        healthy_fraction = healthy_pixels / total_valid_pixels

        # Classifica√ß√£o geral da mata ciliar
        if critical_fraction > 0.3:
            overall_status = 'severely_degraded'
            status_color = '#DC143C'
        elif critical_fraction > 0.1 or moderate_fraction > 0.4:
            overall_status = 'moderately_degraded'
            status_color = '#FF8C00'
        elif moderate_fraction > 0.2:
            overall_status = 'at_risk'
            status_color = '#FFD700'
        else:
            overall_status = 'healthy'
            status_color = '#228B22'

        # Estat√≠sticas detalhadas
        stats = {
            'total_pixels': int(total_valid_pixels),
            'critical_pixels': int(critical_pixels),
            'moderate_pixels': int(moderate_pixels),
            'healthy_pixels': int(healthy_pixels),
            'critical_fraction': float(critical_fraction),
            'moderate_fraction': float(moderate_fraction),
            'healthy_fraction': float(healthy_fraction),
            'ndvi_min': float(np.min(valid_ndvi)),
            'ndvi_max': float(np.max(valid_ndvi)),
            'ndvi_mean': float(np.mean(valid_ndvi)),
            'ndvi_std': float(np.std(valid_ndvi)),
            'overall_status': overall_status,
            'status_color': status_color
        }

        print(f"üìä An√°lise de Degrada√ß√£o da Mata Ciliar:")
        print(f"   üî¥ Cr√≠tico: {critical_pixels:,} pixels ({critical_fraction:.1%})")
        print(f"   üü° Moderado: {moderate_pixels:,} pixels ({moderate_fraction:.1%})")
        print(f"   üü¢ Saud√°vel: {healthy_pixels:,} pixels ({healthy_fraction:.1%})")
        print(f"   üìà NDVI m√©dio: {stats['ndvi_mean']:.3f}")
        print(f"   üè• Status geral: {overall_status}")

        return {
            'ndvi_clipped': ndvi_clipped,
            'buffer_geometry': buffer_reproj,
            'statistics': stats,
            'classification_function': classify_vegetation_degradation
        }

    except Exception as e:
        print(f"‚ùå Erro na an√°lise de degrada√ß√£o: {e}")
        return None

def load_river_geometry_for_buffer():
    """Carrega geometria do rio para criar buffer preciso"""
    
    # Caminhos poss√≠veis para o arquivo do rio
    rio_paths = [
        "../../public/rio.geojson",
        "../public/rio.geojson",
        "rio.geojson",
        "export.geojson",
        "../data/export.geojson"
    ]

    river_gdf = None

    for rio_path in rio_paths:
        if os.path.exists(rio_path):
            print(f"üìÇ Carregando rio: {rio_path}")
            try:
                with open(rio_path, 'r', encoding='utf-8') as f:
                    rio_data = json.load(f)
                river_gdf = gpd.GeoDataFrame.from_features(rio_data['features'], crs='EPSG:4326')
                print(f"   ‚úÖ {len(river_gdf)} features do rio carregadas")
                break
            except Exception as e:
                print(f"   ‚ùå Erro ao carregar {rio_path}: {e}")
                continue

    if river_gdf is None:
        print("‚ö†Ô∏è Arquivo do rio n√£o encontrado, usando AOI buffer existente")
        return None, None

    # Unir geometrias do rio
    try:
        river_union = river_gdf.geometry.union_all()  # M√©todo novo
    except AttributeError:
        river_union = river_gdf.geometry.unary_union  # M√©todo antigo (deprecated)

    print(f"   üåä Geometrias unificadas: {type(river_union)}")

    # Converter para UTM para buffer preciso
    centroid = river_union.centroid if hasattr(river_union, 'centroid') else river_union.geoms[0].centroid
    utm_zone = int((centroid.x + 180) / 6) + 1
    utm_crs = f"EPSG:{32700 + utm_zone}" if centroid.y < 0 else f"EPSG:{32600 + utm_zone}"

    print(f"   üó∫Ô∏è UTM CRS: {utm_crs}")

    # Criar buffer do rio EXCLUINDO a √°rea de √°gua
    river_gdf_unified = gpd.GeoDataFrame([1], geometry=[river_union], crs='EPSG:4326')
    river_utm = river_gdf_unified.to_crs(utm_crs)
    
    # Criar buffer de 200m ao redor do rio
    river_buffer_utm = river_utm.buffer(BUFFER_DISTANCE_RIVER)
    
    # Criar um buffer interno do rio para representar a √°rea de √°gua (expandir o rio)
    # Usar um buffer de 10m para representar a largura do rio
    river_width_buffer = river_utm.buffer(10)  # 10 metros de largura do rio
    
    # EXCLUIR a √°rea expandida do rio do buffer (para n√£o analisar na √°gua)
    river_geom_utm = river_width_buffer.geometry.iloc[0]
    buffer_excluding_water = river_buffer_utm.geometry.iloc[0].difference(river_geom_utm)
    
    # Converter de volta para WGS84
    buffer_excluding_water_gdf = gpd.GeoDataFrame([1], geometry=[buffer_excluding_water], crs=utm_crs)
    buffer_wgs84 = buffer_excluding_water_gdf.to_crs('EPSG:4326')
    buffer_geom = buffer_wgs84.geometry.iloc[0]

    print(f"   üìè Buffer de {BUFFER_DISTANCE_RIVER}m criado EXCLUINDO √°rea de √°gua")
    print(f"   üìç Bounds do buffer: {buffer_wgs84.total_bounds}")
    print(f"   üåä √Årea do rio (10m de largura) exclu√≠da do buffer para an√°lise")

    return river_gdf_unified, buffer_geom

def generate_points_from_real_ndvi(degradation_analysis, river_buffer_geom, max_points_per_category=50):
    """Gera pontos cr√≠ticos baseados no NDVI real da an√°lise de degrada√ß√£o"""
    
    if not degradation_analysis or 'ndvi_clipped' not in degradation_analysis:
        print("‚ùå Dados NDVI n√£o dispon√≠veis para gera√ß√£o de pontos")
        return None
    
    ndvi_clipped = degradation_analysis['ndvi_clipped']
    valid_ndvi = ndvi_clipped.values[~np.isnan(ndvi_clipped.values)]
    
    if len(valid_ndvi) == 0:
        print("‚ùå Nenhum pixel NDVI v√°lido para gerar pontos")
        return None
    
    print(f"üìä Gerando pontos baseados em {len(valid_ndvi)} pixels NDVI reais")
    
    # Diagn√≥stico do buffer do rio
    print(f"   üîç Diagn√≥stico do buffer do rio:")
    print(f"      - Tipo: {type(river_buffer_geom)}")
    print(f"      - Bounds: {river_buffer_geom.bounds}")
    print(f"      - √Årea: {river_buffer_geom.area:.2f} graus¬≤")
    
    # Usar a geometria do rio que foi carregada durante a busca da AOI
    print(f"   üåä Usando geometria do rio da an√°lise de degrada√ß√£o para c√°lculo de dist√¢ncia...")
    
    # Extrair a geometria do rio do buffer da an√°lise de degrada√ß√£o
    # O buffer foi criado a partir dos rios originais, ent√£o podemos usar isso
    river_geom_utm = None
    
    # Tentar obter a geometria do rio original do buffer
    try:
        # O buffer cont√©m a geometria dos rios + 200m, ent√£o vamos extrair apenas os rios
        # Para isso, vamos usar uma aproxima√ß√£o: assumir que o centro do buffer est√° pr√≥ximo ao rio
        buffer_centroid = river_buffer_geom.centroid
        print(f"   üìç Centro do buffer (aproxima√ß√£o do rio): ({buffer_centroid.x:.6f}, {buffer_centroid.y:.6f})")
        
        # Converter para UTM para c√°lculo de dist√¢ncia
        ndvi_crs = ndvi_clipped.rio.crs
        buffer_gdf_temp = gpd.GeoDataFrame([1], geometry=[buffer_centroid], crs='EPSG:4326')
        river_centroid_utm = buffer_gdf_temp.to_crs(ndvi_crs).geometry.iloc[0]
        
        # Usar o centro como aproxima√ß√£o do rio para c√°lculo de dist√¢ncia
        river_geom_utm = river_centroid_utm
        print(f"   ‚úÖ Usando centro do buffer como aproxima√ß√£o do rio para c√°lculo de dist√¢ncia")
        
    except Exception as e:
        print(f"   ‚ö†Ô∏è Erro ao extrair geometria do rio: {e}")
        print("   ‚ö†Ô∏è Usando dist√¢ncia padr√£o de 0m")
        river_geom_utm = None
    
    # Converter buffer do rio para o mesmo CRS do NDVI
    ndvi_crs = ndvi_clipped.rio.crs
    print(f"   üîÑ Convertendo buffer do rio para CRS do NDVI: {ndvi_crs}")
    
    # Verificar se o CRS est√° correto (agora as bandas j√° v√™m com CRS correto)
    print(f"   ‚úÖ NDVI j√° est√° no CRS correto: {ndvi_crs}")
    
    # Verificar se o buffer j√° est√° no CRS correto
    print(f"   üîç Verificando CRS do buffer:")
    print(f"      - Buffer bounds: {river_buffer_geom.bounds}")
    print(f"      - NDVI CRS: {ndvi_crs}")
    
    # Verificar se as coordenadas j√° est√£o em UTM (valores grandes)
    bounds = river_buffer_geom.bounds
    minx, miny, maxx, maxy = bounds
    
    # Se as coordenadas s√£o grandes (> 1000), provavelmente j√° est√£o em UTM
    if minx > 1000 and miny > 1000:
        print(f"   ‚úÖ Buffer j√° est√° em UTM, usando diretamente")
        river_buffer_geom_utm = river_buffer_geom
    else:
        print(f"   üîÑ Convertendo buffer de WGS84 para UTM...")
        
        # Validar geometria original antes da convers√£o
        print(f"   üîç Validando geometria original:")
        print(f"      - Buffer WGS84 v√°lido: {river_buffer_geom.is_valid}")
        print(f"      - Buffer WGS84 bounds: {river_buffer_geom.bounds}")
        print(f"      - Buffer WGS84 √°rea: {river_buffer_geom.area:.10f}")
        
        if not river_buffer_geom.is_valid:
            print(f"   ‚ö†Ô∏è Geometria inv√°lida detectada! Aplicando corre√ß√£o...")
            river_buffer_geom = river_buffer_geom.buffer(0)  # Corre√ß√£o de geometria inv√°lida
            print(f"      - Ap√≥s corre√ß√£o - V√°lido: {river_buffer_geom.is_valid}")
        
        # Verificar se a geometria est√° vazia
        if river_buffer_geom.is_empty:
            print(f"   ‚ùå Geometria do buffer est√° vazia!")
            return None
        
        try:
            # Criar GeoDataFrame tempor√°rio para convers√£o
            river_gdf_temp = gpd.GeoDataFrame([1], geometry=[river_buffer_geom], crs='EPSG:4326')
            river_buffer_utm = river_gdf_temp.to_crs(ndvi_crs)
            river_buffer_geom_utm = river_buffer_utm.geometry.iloc[0]
            
            print(f"   ‚úÖ Buffer convertido para UTM")
            print(f"      - Bounds UTM: {river_buffer_geom_utm.bounds}")
            print(f"      - √Årea UTM: {river_buffer_geom_utm.area:.2f} m¬≤")
            
            # Verificar se a convers√£o resultou em geometria v√°lida
            if not river_buffer_geom_utm.is_valid or river_buffer_geom_utm.is_empty:
                print(f"   ‚ùå Convers√£o UTM resultou em geometria inv√°lida ou vazia!")
                print(f"      - V√°lido: {river_buffer_geom_utm.is_valid}")
                print(f"      - Vazio: {river_buffer_geom_utm.is_empty}")
                return None
                
        except Exception as e:
            print(f"   ‚ùå Erro na convers√£o UTM: {e}")
            return None
    
    # Verificar se h√° problema de hemisf√©rio (coordenadas Y negativas vs positivas)
    ndvi_bounds = ndvi_clipped.rio.bounds()
    ndvi_y_center = (ndvi_bounds[1] + ndvi_bounds[3]) / 2
    buffer_y_center = (river_buffer_geom_utm.bounds[1] + river_buffer_geom_utm.bounds[3]) / 2
    
    print(f"   üîç Diagn√≥stico de coordenadas:")
    print(f"      - NDVI Y center: {ndvi_y_center}")
    print(f"      - Buffer Y center: {buffer_y_center}")
    
    # Verificar se h√° bounds infinitos (problema de convers√£o)
    bounds = river_buffer_geom_utm.bounds
    if any(not np.isfinite(b) for b in bounds):
        print(f"   ‚ùå Bounds infinitos detectados ap√≥s convers√£o UTM!")
        print(f"   üîß Aplicando fallback: usando buffer da AOI diretamente...")
        
        # Fallback: usar o buffer da an√°lise de degrada√ß√£o diretamente
        if 'buffer_geometry' in degradation_analysis:
            print(f"   üìç Usando buffer da an√°lise de degrada√ß√£o como fallback")
            buffer_gdf = degradation_analysis['buffer_geometry']
            buffer_geom_wgs84 = buffer_gdf.geometry.iloc[0]
            
            # Converter para UTM usando o mesmo CRS do NDVI
            buffer_gdf_temp = gpd.GeoDataFrame([1], geometry=[buffer_geom_wgs84], crs='EPSG:4326')
            buffer_utm = buffer_gdf_temp.to_crs(ndvi_crs)
            river_buffer_geom_utm = buffer_utm.geometry.iloc[0]
            
            print(f"   ‚úÖ Fallback aplicado com sucesso")
            print(f"      - Bounds UTM fallback: {river_buffer_geom_utm.bounds}")
            print(f"      - √Årea UTM fallback: {river_buffer_geom_utm.area:.2f} m¬≤")
        else:
            print(f"   ‚ùå Nenhum fallback dispon√≠vel!")
            return None
    
    # Se h√° incompatibilidade de hemisf√©rio, corrigir
    elif (ndvi_y_center < 0 and buffer_y_center > 0) or (ndvi_y_center > 0 and buffer_y_center < 0):
        print(f"   ‚ö†Ô∏è Incompatibilidade de hemisf√©rio detectada!")
        print(f"   üîß Aplicando corre√ß√£o de hemisf√©rio...")
        
        # Aplicar offset de 10,000,000m para corrigir hemisf√©rio
        y_offset = -10000000 if ndvi_y_center < 0 else 10000000
        
        def fix_hemisphere(geom):
            def coord_transform(x, y, z=None):
                return (x, y + y_offset, z) if z is not None else (x, y + y_offset)
            
            from shapely.ops import transform
            return transform(coord_transform, geom)
        
        river_buffer_geom_utm = fix_hemisphere(river_buffer_geom_utm)
        print(f"   ‚úÖ Hemisf√©rio corrigido")
        print(f"      - Bounds UTM corrigido: {river_buffer_geom_utm.bounds}")
        print(f"      - √Årea UTM corrigido: {river_buffer_geom_utm.area:.2f} m¬≤")
    
    # Classificar pixels reais por severidade no array 2D
    ndvi_values = ndvi_clipped.values
    valid_mask = ~np.isnan(ndvi_values)
    
    critical_mask_2d = (ndvi_values < NDVI_CRITICAL_THRESHOLD) & valid_mask
    moderate_mask_2d = (ndvi_values >= NDVI_CRITICAL_THRESHOLD) & (ndvi_values < NDVI_MODERATE_THRESHOLD) & valid_mask
    healthy_mask_2d = (ndvi_values >= NDVI_MODERATE_THRESHOLD) & valid_mask
    
    critical_pixels_count = np.sum(critical_mask_2d)
    moderate_pixels_count = np.sum(moderate_mask_2d)
    healthy_pixels_count = np.sum(healthy_mask_2d)
    
    print(f"   üî¥ Pixels cr√≠ticos reais: {critical_pixels_count}")
    print(f"   üü° Pixels moderados reais: {moderate_pixels_count}")
    print(f"   üü¢ Pixels saud√°veis reais: {healthy_pixels_count}")
    
    # Fun√ß√£o auxiliar para encontrar coordenadas de pixels
    def find_pixel_coordinates(ndvi_array, mask_2d, n_points):
        """Encontra coordenadas de pixels espec√≠ficos"""
        if np.sum(mask_2d) == 0:
            return []
        
        # Encontrar √≠ndices 2D dos pixels que atendem ao crit√©rio
        y_indices, x_indices = np.where(mask_2d)
        
        # Amostrar pixels se necess√°rio
        if len(y_indices) > n_points:
            sampled_idx = np.random.choice(len(y_indices), n_points, replace=False)
            y_indices = y_indices[sampled_idx]
            x_indices = x_indices[sampled_idx]
        
        points = []
        transform = ndvi_array.rio.transform()
        
        for y_idx, x_idx in zip(y_indices, x_indices):
            # Converter para coordenadas UTM (rasterio.transform.xy retorna x=easting, y=northing)
            easting, northing = rasterio.transform.xy(transform, y_idx, x_idx)
            
            # Verificar se est√° dentro do buffer do rio (usar buffer UTM)
            point_geom = Point(easting, northing)
            is_inside = river_buffer_geom_utm.contains(point_geom)
            
            # Debug: mostrar alguns pontos para diagn√≥stico
            if len(points) < 3:  # Mostrar apenas os primeiros 3 para debug
                print(f"      Debug - Ponto {len(points)+1}: ({easting:.6f}, {northing:.6f}) - Dentro do buffer: {is_inside}")
            
            if is_inside:
                ndvi_value = float(ndvi_array.values[y_idx, x_idx])
                
                # Calcular dist√¢ncia do rio
                distance_to_river_m = 0
                if river_geom_utm is not None:
                    try:
                        point_geom = Point(easting, northing)
                        distance_to_river_m = float(point_geom.distance(river_geom_utm))
                        # Debug: mostrar algumas dist√¢ncias calculadas
                        if len(points) < 3:  # Mostrar apenas os primeiros 3 para debug
                            print(f"      Debug - Dist√¢ncia do rio: {distance_to_river_m:.1f}m")
                    except Exception as e:
                        print(f"      ‚ö†Ô∏è Erro ao calcular dist√¢ncia do rio: {e}")
                        distance_to_river_m = 0
                
                # Determinar categoria baseada no valor NDVI
                if ndvi_value < NDVI_CRITICAL_THRESHOLD:
                    severity = 'critical'
                    level = 'very_sparse'
                    color = '#DC143C'
                    label = 'Vegeta√ß√£o muito rala / solo exposto'
                elif ndvi_value < NDVI_MODERATE_THRESHOLD:
                    severity = 'moderate'
                    level = 'sparse'
                    color = '#FF8C00'
                    label = 'Vegeta√ß√£o esparsa / em regenera√ß√£o'
                else:
                    severity = 'healthy'
                    level = 'dense'
                    color = '#228B22'
                    label = 'Vegeta√ß√£o densa e saud√°vel'
                
                # Converter coordenadas UTM para WGS84 para gerar ID √∫nico
                transformer = Transformer.from_crs("EPSG:32722", "EPSG:4326", always_xy=True)
                lon_wgs84, lat_wgs84 = transformer.transform(easting, northing)
                
                # Gerar ID √∫nico para o ponto
                point_id = generate_unique_point_id(lat_wgs84, lon_wgs84, ndvi_value)
                
                points.append({
                    'id': point_id,  # ID √∫nico gerado
                    'lat': northing,  # northing √© a coordenada Y UTM
                    'lon': easting,   # easting √© a coordenada X UTM
                    'lat_wgs84': lat_wgs84,  # Latitude WGS84 para refer√™ncia
                    'lon_wgs84': lon_wgs84,  # Longitude WGS84 para refer√™ncia
                    'ndvi': ndvi_value,
                    'severity': severity,
                    'level': level,
                    'color': color,
                    'label': label,
                    'description': f"√Årea real - NDVI {ndvi_value:.3f}",
                    'source': 'real_ndvi_analysis',
                    'distance_to_river_m': distance_to_river_m
                })
        
        return points
    
    # Gerar APENAS pontos cr√≠ticos (NDVI < 0.2)
    critical_points = find_pixel_coordinates(ndvi_clipped, critical_mask_2d, 
                                        min(max_points_per_category, critical_pixels_count))
    
    total_points = len(critical_points)
    
    print(f"\nüìä Pontos gerados com NDVI real (APENAS CR√çTICOS):")
    print(f"   üî¥ Cr√≠ticos: {len(critical_points)}")
    print(f"   üìä Total: {total_points}")
    print(f"   ‚ö†Ô∏è  IMPORTANTE: Apenas pontos com NDVI < {NDVI_CRITICAL_THRESHOLD} s√£o inclu√≠dos")
    
    return {
        'critical': critical_points,
        'moderate': [],  # SEMPRE vazio - n√£o gerar pontos moderados
        'fair': [],      # SEMPRE vazio - n√£o gerar pontos saud√°veis  
        'water': [],     # SEMPRE vazio - n√£o gerar pontos de √°gua
        'total_points': total_points,
        'generation_method': 'real_ndvi_based_critical_only',
        'generation_params': {
            'min_distance': MIN_DISTANCE_POINTS,
            'max_points_per_category': max_points_per_category,
            'buffer_distance_m': BUFFER_DISTANCE_RIVER,
            'buffer_constrained': True,
            'real_ndvi_based': True,
            'critical_only': True,  # Flag indicando que apenas pontos cr√≠ticos s√£o gerados
            'thresholds': {
                'critical': NDVI_CRITICAL_THRESHOLD,
                'moderate': NDVI_MODERATE_THRESHOLD
            }
        }
    }
