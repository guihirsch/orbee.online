import React, { useEffect, useRef, useState } from "react";
import maplibregl from "maplibre-gl";
import "maplibre-gl/dist/maplibre-gl.css";
import { fromUrl as geotiffFromUrl } from "geotiff";
import proj4 from "proj4";

// Helper: build a blob URL for local file via fetch
async function createObjectUrl(path) {
   const res = await fetch(path);
   if (!res.ok) throw new Error(`Falha ao carregar arquivo: ${path}`);
   const blob = await res.blob();
   return URL.createObjectURL(blob);
}

export default function AOIViewer() {
   const mapRef = useRef(null);
   const containerRef = useRef(null);
   const [loaded, setLoaded] = useState(false);
   const [baseLayer, setBaseLayer] = useState("osm"); // "osm" | "sat"
   const [rgbVisible, setRgbVisible] = useState(false);
   const [rgbAvailable, setRgbAvailable] = useState(false);

   useEffect(() => {
      if (mapRef.current) return;
      mapRef.current = new maplibregl.Map({
         container: containerRef.current,
         style: {
            version: 8,
            sources: {
               osm: {
                  type: "raster",
                  tiles: [
                     "https://a.tile.openstreetmap.org/{z}/{x}/{y}.png",
                     "https://b.tile.openstreetmap.org/{z}/{x}/{y}.png",
                     "https://c.tile.openstreetmap.org/{z}/{x}/{y}.png",
                  ],
                  tileSize: 256,
                  attribution: "© OpenStreetMap contributors",
               },
               sat: {
                  type: "raster",
                  tiles: [
                     "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
                  ],
                  tileSize: 256,
                  attribution:
                     "Tiles © Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community",
               },
            },
            layers: [
               {
                  id: "sat",
                  type: "raster",
                  source: "sat",
                  layout: { visibility: "none" },
               },
               { id: "osm", type: "raster", source: "osm" },
            ],
         },
         center: [-52.4264, -29.475], // Centrado no rio em Y
         zoom: 13, // Zoom mais próximo para ver detalhes
      });

      mapRef.current.addControl(
         new maplibregl.NavigationControl(),
         "top-right"
      );

      mapRef.current.on("load", async () => {
         try {
            // ensure base layer visibility on init
            mapRef.current.setLayoutProperty(
               "osm",
               "visibility",
               baseLayer === "osm" ? "visible" : "none"
            );
            mapRef.current.setLayoutProperty(
               "sat",
               "visibility",
               baseLayer === "sat" ? "visible" : "none"
            );
            // Try to load optional RGB GeoTIFF first
            try {
               const rgbTiff = await geotiffFromUrl(
                  "/rgb_mosaic_super_resolved.tif"
               );
               const rgbImg = await rgbTiff.getImage();
               const rw = rgbImg.getWidth();
               const rh = rgbImg.getHeight();
               // Read B04,B03,B02 (indices 2,1,0) scaled 0..10000
               const rgbData = await rgbImg.readRasters({
                  samples: [2, 1, 0],
                  interleave: false,
               });
               const [rArr, gArr, bArr] = rgbData; // typed arrays
               const rCanvas = document.createElement("canvas");
               rCanvas.width = rw;
               rCanvas.height = rh;
               const rCtx = rCanvas.getContext("2d");
               const rImgData = rCtx.createImageData(rw, rh);

               // Compute per-channel min/max ignoring zeros/NaNs for stretch
               const computeMinMax = (arr) => {
                  let min = Infinity,
                     max = -Infinity;
                  for (let i = 0; i < arr.length; i++) {
                     const v = arr[i];
                     if (!Number.isFinite(v) || v === 0) continue;
                     if (v < min) min = v;
                     if (v > max) max = v;
                  }
                  if (
                     !Number.isFinite(min) ||
                     !Number.isFinite(max) ||
                     min >= max
                  ) {
                     return [0, 10000];
                  }
                  return [min, max];
               };
               const [rMin, rMax] = computeMinMax(rArr);
               const [gMin, gMax] = computeMinMax(gArr);
               const [bMin, bMax] = computeMinMax(bArr);

               const scale = (v, min, max) => {
                  if (!Number.isFinite(v)) return 0;
                  const x = (v - min) / (max - min);
                  return Math.max(0, Math.min(1, x));
               };
               const gamma = 1 / 1.6;

               for (let i = 0; i < rw * rh; i++) {
                  const o = i * 4;
                  const rN = scale(rArr[i], rMin, rMax);
                  const gN = scale(gArr[i], gMin, gMax);
                  const bN = scale(bArr[i], bMin, bMax);
                  // transparent when no data (all near zero)
                  const isNoData =
                     (rArr[i] === 0 && gArr[i] === 0 && bArr[i] === 0) ||
                     (!Number.isFinite(rArr[i]) &&
                        !Number.isFinite(gArr[i]) &&
                        !Number.isFinite(bArr[i]));
                  if (isNoData) {
                     rImgData.data[o] = 0;
                     rImgData.data[o + 1] = 0;
                     rImgData.data[o + 2] = 0;
                     rImgData.data[o + 3] = 0;
                     continue;
                  }
                  rImgData.data[o] = Math.round(255 * Math.pow(rN, gamma));
                  rImgData.data[o + 1] = Math.round(255 * Math.pow(gN, gamma));
                  rImgData.data[o + 2] = Math.round(255 * Math.pow(bN, gamma));
                  rImgData.data[o + 3] = 255;
               }
               rCtx.putImageData(rImgData, 0, 0);

               // Bounds and reprojection
               const [rxmin, rymin, rxmax, rymax] = rgbImg.getBoundingBox();
               const rGeoKeys = rgbImg.getGeoKeys();
               let rToLngLat = (x, y) => [x, y];
               try {
                  const repsg =
                     rGeoKeys.ProjectedCSTypeGeoKey ||
                     rGeoKeys.GeographicTypeGeoKey;
                  if (repsg) {
                     const rsrc = `EPSG:${repsg}`;
                     if (rsrc !== "EPSG:4326") {
                        rToLngLat = (x, y) => proj4(rsrc, "EPSG:4326", [x, y]);
                     }
                  }
               } catch {}

               const rtl = rToLngLat(rxmin, rymax);
               const rtr = rToLngLat(rxmax, rymax);
               const rbr = rToLngLat(rxmax, rymin);
               const rbl = rToLngLat(rxmin, rymin);

               mapRef.current.addSource("rgb-image", {
                  type: "image",
                  url: rCanvas.toDataURL(),
                  coordinates: [rtl, rtr, rbr, rbl],
               });
               mapRef.current.addLayer({
                  id: "rgb-layer",
                  type: "raster",
                  source: "rgb-image",
                  paint: { "raster-opacity": 0.9 },
               });
               // respeitar visibilidade inicial
               mapRef.current.setLayoutProperty(
                  "rgb-layer",
                  "visibility",
                  rgbVisible ? "visible" : "none"
               );
               setRgbAvailable(true);
            } catch (_) {
               // RGB optional; ignore errors
            }

            // Render NDVI GeoTIFF into canvas and add as image source
            try {
               console.log("🔄 Carregando NDVI GeoTIFF...");
               const tiff = await geotiffFromUrl(
                  "/ndvi_mosaic_super_resolved.tif"
               );
               console.log("✅ NDVI GeoTIFF carregado com sucesso");
               const image = await tiff.getImage();
               const width = image.getWidth();
               const height = image.getHeight();
               const nodataMeta = image.getGDALNoData();
               const data = await image.readRasters({
                  samples: [0],
                  interleave: true,
               });

               // Build normalized NDVI in [-1, 1] - melhor tratamento de NoData
               let minVal = Infinity;
               let maxVal = -Infinity;
               let validCount = 0;

               for (let i = 0; i < data.length; i++) {
                  const v = data[i];
                  // Filtrar apenas NoData real (não filtrar zeros válidos)
                  if (v === nodataMeta || !Number.isFinite(v) || v === -9999.0)
                     continue;
                  if (v < minVal) minVal = v;
                  if (v > maxVal) maxVal = v;
                  validCount++;
               }

               console.log(
                  `📊 Pixels válidos: ${validCount}/${data.length} (${((validCount / data.length) * 100).toFixed(1)}%)`
               );
               console.log(
                  `📈 Range NDVI: ${minVal.toFixed(3)} a ${maxVal.toFixed(3)}`
               );

               // Melhor detecção de escala NDVI
               let scaleFn = (v) => v; // identity

               console.log(
                  `🔍 Detectando escala: min=${minVal}, max=${maxVal}`
               );

               if (maxVal > 10000) {
                  // Escala Sentinel (0..10000) -> [-1,1]
                  console.log("📏 Detectado: Escala Sentinel (0-10000)");
                  scaleFn = (v) =>
                     v === nodataMeta || !Number.isFinite(v)
                        ? NaN
                        : (v / 10000) * 2 - 1;
               } else if (maxVal > 1.5) {
                  // Escala 0..255 ou similar -> [-1,1]
                  console.log("📏 Detectado: Escala 8-bit ou similar");
                  scaleFn = (v) =>
                     v === nodataMeta || !Number.isFinite(v)
                        ? NaN
                        : (v / 255) * 2 - 1;
               } else if (minVal >= 0 && maxVal <= 1.1) {
                  // Escala 0..1 -> [-1,1]
                  console.log("📏 Detectado: Escala 0-1");
                  scaleFn = (v) =>
                     v === nodataMeta || !Number.isFinite(v) ? NaN : v * 2 - 1;
               } else if (minVal >= -1 && maxVal <= 1) {
                  // Já está em [-1,1]
                  console.log("📏 Detectado: Escala -1 a 1 (nativa)");
                  scaleFn = (v) =>
                     v === nodataMeta || !Number.isFinite(v) ? NaN : v;
               } else {
                  // Range customizado - normalizar para [-1,1]
                  console.log("📏 Detectado: Range customizado, normalizando");
                  const range = maxVal - minVal;
                  scaleFn = (v) =>
                     v === nodataMeta || !Number.isFinite(v)
                        ? NaN
                        : ((v - minVal) / range) * 2 - 1;
               }

               const canvas = document.createElement("canvas");
               canvas.width = width;
               canvas.height = height;
               const ctx = canvas.getContext("2d");
               const imgData = ctx.createImageData(width, height);
               // Better resampling on display
               ctx.imageSmoothingEnabled = true;

               // Usar range dinâmico baseado nos dados reais
               const NDVI_MIN = Math.max(-1, minVal);
               const NDVI_MAX = Math.min(1, maxVal);

               console.log(
                  `🎯 Range usado para visualização: ${NDVI_MIN.toFixed(3)} a ${NDVI_MAX.toFixed(3)}`
               );
               // Some writers store rows bottom->top. Draw explicitly by row/col and flip if needed.
               const nodataVal =
                  nodataMeta != null ? parseFloat(nodataMeta) : undefined;
               for (let y = 0; y < height; y++) {
                  // change to `const srcY = height - 1 - y;` if image appears vertically flipped
                  const srcY = y;
                  for (let x = 0; x < width; x++) {
                     const srcIdx = srcY * width + x;
                     let v = data[srcIdx];

                     // Tratar apenas NoData real (manter zeros válidos)
                     const isNoData =
                        (nodataVal !== undefined && v === nodataVal) ||
                        v === -9999.0 ||
                        !Number.isFinite(v);

                     if (isNoData) {
                        v = NaN;
                     } else {
                        v = scaleFn(v);
                     }

                     const dstIdx = (y * width + x) * 4;
                     if (Number.isFinite(v) && !isNoData) {
                        const t = Math.min(
                           1,
                           Math.max(0, (v - NDVI_MIN) / (NDVI_MAX - NDVI_MIN))
                        );
                        // Esquema de cores padrão NDVI (como no Colab)
                        let r, g, b;
                        if (v < -0.2) {
                           // Água/superfície não vegetada - azul/vermelho
                           r = 139;
                           g = 69;
                           b = 19; // marrom
                        } else if (v < 0.2) {
                           // Solo nu/pouca vegetação - vermelho/laranja
                           r = Math.round(255 * (1 - (v + 0.2) / 0.4));
                           g = Math.round((165 * (v + 0.2)) / 0.4);
                           b = 0;
                        } else if (v < 0.5) {
                           // Vegetação moderada - amarelo/verde claro
                           r = Math.round(255 * (1 - (v - 0.2) / 0.3));
                           g = 255;
                           b = Math.round((100 * (v - 0.2)) / 0.3);
                        } else {
                           // Vegetação densa - verde
                           r = Math.round(50 * (1 - (v - 0.5) / 0.5));
                           g = 255;
                           b = Math.round(50 * (1 - (v - 0.5) / 0.5));
                        }

                        imgData.data[dstIdx] = r;
                        imgData.data[dstIdx + 1] = g;
                        imgData.data[dstIdx + 2] = b;
                        imgData.data[dstIdx + 3] = 220; // Semi-transparente
                     } else {
                        // NoData - completamente transparente
                        imgData.data[dstIdx] = 0;
                        imgData.data[dstIdx + 1] = 0;
                        imgData.data[dstIdx + 2] = 0;
                        imgData.data[dstIdx + 3] = 0;
                     }
                  }
               }
               ctx.putImageData(imgData, 0, 0);

               // Get bounds in source CRS
               const [xmin, ymin, xmax, ymax] = image.getBoundingBox();
               // Detect CRS via GeoKeys and reproject to WGS84 if necessary
               const geoKeys = image.getGeoKeys();
               let toLngLat = (x, y) => [x, y];
               try {
                  const epsgNum =
                     geoKeys.ProjectedCSTypeGeoKey ||
                     geoKeys.GeographicTypeGeoKey;
                  if (epsgNum) {
                     const src = `EPSG:${epsgNum}`;
                     if (src !== "EPSG:4326") {
                        toLngLat = (x, y) => proj4(src, "EPSG:4326", [x, y]);
                     }
                  }
               } catch {}

               const tl = toLngLat(xmin, ymax);
               const tr = toLngLat(xmax, ymax);
               const br = toLngLat(xmax, ymin);
               const bl = toLngLat(xmin, ymin);
               const coordinates = [tl, tr, br, bl];

               mapRef.current.addSource("ndvi-image", {
                  type: "image",
                  url: canvas.toDataURL(),
                  coordinates,
               });
               mapRef.current.addLayer({
                  id: "ndvi-layer",
                  type: "raster",
                  source: "ndvi-image",
                  paint: { "raster-opacity": 0.75 },
               });
               // respeitar visibilidade inicial
               mapRef.current.setLayoutProperty(
                  "ndvi-layer",
                  "visibility",
                  ndviVisible ? "visible" : "none"
               );
            } catch (ndviError) {
               console.error("❌ Erro ao carregar NDVI GeoTIFF:", ndviError);
               console.log(
                  "💡 Verifique se o arquivo ndvi_mosaic_super_resolved.tif existe na pasta public/"
               );
               // Continuar sem NDVI - não é crítico
            }

            // Adiciona camada de tiles (GeoJSON) com tooltip
            try {
               const tilesRes = await fetch("/tiles_grid.geojson");
               if (tilesRes.ok) {
                  const tilesGeo = await tilesRes.json();

                  if (!mapRef.current.getSource("tiles-grid")) {
                     mapRef.current.addSource("tiles-grid", {
                        type: "geojson",
                        data: tilesGeo,
                     });
                  }

                  if (!mapRef.current.getLayer("tiles-grid-fill")) {
                     mapRef.current.addLayer({
                        id: "tiles-grid-fill",
                        type: "fill",
                        source: "tiles-grid",
                        paint: {
                           "fill-color": [
                              "match",
                              ["get", "severity"],
                              "severe",
                              "#ff3b30",
                              "moderate",
                              "#ffcc00",
                              /* default */ "#00c853",
                           ],
                           "fill-opacity": 0.12,
                        },
                     });
                  }

                  // Outline por severidade (cores consistentes com fill)
                  if (!mapRef.current.getLayer("tiles-grid-outline")) {
                     mapRef.current.addLayer({
                        id: "tiles-grid-outline",
                        type: "line",
                        source: "tiles-grid",
                        paint: {
                           "line-color": [
                              "match",
                              ["get", "severity"],
                              "severe",
                              "#ff3b30",
                              "moderate",
                              "#ffcc00",
                              /* default */ "#00c853",
                           ],
                           "line-width": 2,
                           "line-opacity": 0.9,
                        },
                     });
                  }

                  const popup = new maplibregl.Popup({
                     closeButton: false,
                     closeOnClick: false,
                  });
                  mapRef.current.on("mousemove", "tiles-grid-fill", (e) => {
                     if (!e.features?.length) return;
                     const f = e.features[0];
                     const p = f.properties || {};
                     const html = `
                       <div style="min-width:220px">
                         <div><b>Tile:</b> ${p.tile_id}</div>
                         <div><b>Severidade:</b> ${p.severity}</div>
                         <div><b>Frac. crítica:</b> ${p.frac_crit}</div>
                         <div><b>Frac. moderada:</b> ${p.frac_mod}</div>
                         <div><b>SR disponível:</b> ${p.has_sr === "true" || p.has_sr === true ? "Sim" : "Não"}</div>
                         <div><b>Nuvem (global):</b> ${p.sel_cloud ?? "n/d"}%</div>
                         <div><b>Nuvem local (SCL):</b> ${p.nuvem_local_pct ?? "n/d"}%</div>
                       </div>`;
                     popup
                        .setLngLat(e.lngLat)
                        .setHTML(html)
                        .addTo(mapRef.current);
                  });
                  mapRef.current.on("mouseleave", "tiles-grid-fill", () =>
                     popup.remove()
                  );

                  // Clique no tile: zoom no bbox (se disponível) e popup detalhado
                  mapRef.current.on("click", "tiles-grid-fill", (e) => {
                     if (!e.features?.length) return;
                     const f = e.features[0];
                     const p = f.properties || {};
                     const b = f.bbox || f.geometry?.bbox || null;
                     if (b && Array.isArray(b) && b.length === 4) {
                        mapRef.current.fitBounds(
                           [
                              [b[0], b[1]],
                              [b[2], b[3]],
                           ],
                           { padding: 40, duration: 600 }
                        );
                     }
                     new maplibregl.Popup()
                        .setLngLat(e.lngLat)
                        .setHTML(
                           `
                          <div style="min-width:240px">
                            <div><b>Tile:</b> ${p.tile_id}</div>
                            <div><b>Severidade:</b> ${p.severity}</div>
                            <div><b>Frac. crítica:</b> ${p.frac_crit}</div>
                            <div><b>Frac. moderada:</b> ${p.frac_mod}</div>
                            <div><b>SR disponível:</b> ${p.has_sr === "true" || p.has_sr === true ? "Sim" : "Não"}</div>
                            <div><b>Nuvem (global):</b> ${p.sel_cloud ?? "n/d"}%</div>
                            <div><b>Nuvem local (SCL):</b> ${p.nuvem_local_pct ?? "n/d"}%</div>
                          </div>
                        `
                        )
                        .addTo(mapRef.current);
                  });

                  // Legenda simples de severidade
                  try {
                     const legendId = "tiles-legend";
                     if (!document.getElementById(legendId)) {
                        const legend = document.createElement("div");
                        legend.id = legendId;
                        legend.className =
                           "absolute right-3 top-3 z-10 bg-white/90 shadow rounded px-3 py-2 text-xs";
                        legend.innerHTML = `
                          <div><b>Severidade (tiles)</b></div>
                          <div style="display:flex;gap:6px;align-items:center"><span style="width:10px;height:10px;background:#ff3b30;display:inline-block"></span> severa</div>
                          <div style="display:flex;gap:6px;align-items:center"><span style="width:10px;height:10px;background:#ffcc00;display:inline-block"></span> moderada</div>
                          <div style="display:flex;gap:6px;align-items:center"><span style="width:10px;height:10px;background:#00c853;display:inline-block"></span> ok</div>
                        `;
                        containerRef.current.appendChild(legend);
                     }
                  } catch {}
               }
            } catch {}

            // Adicionar AOI (opcional) se disponível em /export.geojson
            try {
               const aoiRes = await fetch("/export.geojson");
               if (aoiRes.ok) {
                  const aoiGeo = await aoiRes.json();
                  if (!mapRef.current.getSource("aoi")) {
                     mapRef.current.addSource("aoi", {
                        type: "geojson",
                        data: aoiGeo,
                     });
                  }
                  if (!mapRef.current.getLayer("aoi-fill")) {
                     mapRef.current.addLayer({
                        id: "aoi-fill",
                        type: "fill",
                        source: "aoi",
                        paint: { "fill-color": "#00c853", "fill-opacity": 0.1 },
                     });
                  }
                  if (!mapRef.current.getLayer("aoi-line")) {
                     mapRef.current.addLayer({
                        id: "aoi-line",
                        type: "line",
                        source: "aoi",
                        paint: {
                           "line-color": "#00a147",
                           "line-width": 2,
                           "line-opacity": 0.8,
                        },
                     });
                  }
               }
            } catch {}

            setLoaded(true);
         } catch (e) {
            console.error("Erro ao carregar GeoTIFF no MapLibre:", e);
         }
      });

      return () => {
         if (mapRef.current) {
            mapRef.current.remove();
            mapRef.current = null;
         }
      };
   }, []);

   // React to baseLayer changes
   useEffect(() => {
      if (!mapRef.current) return;
      if (mapRef.current.getLayer("osm")) {
         mapRef.current.setLayoutProperty(
            "osm",
            "visibility",
            baseLayer === "osm" ? "visible" : "none"
         );
      }
      if (mapRef.current.getLayer("sat")) {
         mapRef.current.setLayoutProperty(
            "sat",
            "visibility",
            baseLayer === "sat" ? "visible" : "none"
         );
      }
   }, [baseLayer]);

   useEffect(() => {
      if (!loaded || !mapRef.current) return;
      if (mapRef.current.getLayer("rgb-layer")) {
         mapRef.current.setLayoutProperty(
            "rgb-layer",
            "visibility",
            rgbVisible ? "visible" : "none"
         );
      }
   }, [rgbVisible, loaded]);

   useEffect(() => {
      if (!loaded || !mapRef.current) return;
      if (mapRef.current.getLayer("ndvi-layer")) {
         mapRef.current.setLayoutProperty(
            "ndvi-layer",
            "visibility",
            ndviVisible ? "visible" : "none"
         );
      }
   }, [ndviVisible, loaded]);

   return (
      <div className="h-screen w-full relative">
         <div ref={containerRef} className="h-full w-full" />
         <div className="absolute left-3 top-3 z-10 space-x-2 bg-white/90 shadow rounded px-3 py-2">
            <div className="mb-1 space-x-2 text-sm">
               <label>
                  <input
                     type="radio"
                     name="base"
                     checked={baseLayer === "osm"}
                     onChange={() => setBaseLayer("osm")}
                  />{" "}
                  OSM
               </label>
               <label>
                  <input
                     type="radio"
                     name="base"
                     checked={baseLayer === "sat"}
                     onChange={() => setBaseLayer("sat")}
                  />{" "}
                  Satélite
               </label>
            </div>
            <label className="mr-3 text-sm">
               <input
                  type="checkbox"
                  checked={ndviVisible}
                  onChange={(e) => {
                     const v = e.target.checked;
                     setNdviVisible(v);
                     if (v) setRgbVisible(false);
                  }}
               />{" "}
               NDVI
            </label>
            <label className="text-sm opacity-60">
               <input
                  type="checkbox"
                  checked={rgbVisible}
                  onChange={(e) => {
                     const v = e.target.checked;
                     setRgbVisible(v);
                     if (v) setNdviVisible(false);
                  }}
                  disabled={!rgbAvailable}
               />{" "}
               RGB (opcional)
            </label>
         </div>
      </div>
   );
}
